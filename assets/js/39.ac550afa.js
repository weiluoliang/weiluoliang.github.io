(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{395:function(a,s,t){"use strict";t.r(s);var r=t(15),e=Object(r.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),s("p",[a._v("Java是跨平台语言，看官方给的一张图，我们写的Java代码在最上层 ，最终通过Java虚拟机帮助我们去运行，根据不同操作系统翻译成不同的机器码运行，从而实现了跨平台的特性。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://images.luoliang.top/jdk.png",alt:"img"}})]),a._v(" "),s("h2",{attrs:{id:"运行时数据区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区"}},[a._v("#")]),a._v(" 运行时数据区")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://images.luoliang.top/jvm_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png",alt:"img"}})]),a._v(" "),s("p",[a._v("启动java的参数示例")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("java "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Xms2048M")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Xmx2048M")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Xmn1024M")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Xss512K")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("XX")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MetaspaceSize")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("256")]),a._v("M "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("XX")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MaxMetaspaceSize")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("256")]),a._v("M "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("jar microservice"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("eureka"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("server"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("jar \n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("-Xms:初始堆大小\n-Xmx:最大堆大小\n-Xmn:新生代大小\n-Xss:栈大小\n-XX:MetaspaceSize:初始元空间大小\n-XX:MaxMetaspaceSize:最大元空间大小")]),a._v(" "),s("h3",{attrs:{id:"堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),s("p",[a._v("堆分为新生代和老年代，新生代又分为Eden区和Survivor区，老年代是存放长期存活的对象，新生代是存放新创建的对象。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://images.luoliang.top/jvm_%E5%A0%86%E7%BB%93%E6%9E%84.png",alt:"img"}})]),a._v(" "),s("h3",{attrs:{id:"方法区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),s("p",[a._v("方法区是一个抽象概念，在不同的Java版本中有不同的实现。 在JDK1.8之前，使用永久代实现，在JDK1.8之后，方法区被元空间取代。")]),a._v(" "),s("p",[a._v("方法区都存什么内容？")]),a._v(" "),s("ul",[s("li",[a._v("类信息")]),a._v(" "),s("li",[a._v("静态变量")]),a._v(" "),s("li",[a._v("class常量池 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译期生成的各种字面量(Literal)和符号引用(Symbolic References)。")])]),a._v(" "),s("p",[a._v("我们一般可以通过javap命令生成更可读的JVM字节码指令文件：javap -v Math.class")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://images.luoliang.top/jvm_%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_%E5%8F%8D%E7%BC%96%E8%AF%91%E5%AD%97%E8%8A%82%E7%A0%81.png",alt:"img"}})]),a._v(" "),s("h3",{attrs:{id:"虚拟机栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[a._v("#")]),a._v(" 虚拟机栈")]),a._v(" "),s("p",[a._v("虚拟机栈里面放的是一个个栈帧，每个栈帧对应一个方法，结构如下：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://images.luoliang.top/jvm_%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.png",alt:"img"}})]),a._v(" "),s("ul",[s("li",[a._v("局部变量表 存放方法执行过程中的局部变量")]),a._v(" "),s("li",[a._v("操作数栈 存放方法执行过程中的临时变量，以及方法执行过程中的计算结果")]),a._v(" "),s("li",[a._v("动态链接 指向运行时常量池中该方法的引用")]),a._v(" "),s("li",[a._v("方法出口 方法执行完成后的返回地址")])]),a._v(" "),s("h3",{attrs:{id:"程序计数器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),s("p",[a._v("下一条指令的地址，每个线程都有一个程序计数器，不会出现内存溢出的情况。")]),a._v(" "),s("h3",{attrs:{id:"本地方法栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),s("p",[a._v("本地方法栈是为了执行本地方法服务的，与虚拟机栈类似，只不过是为本地方法服务的。")]),a._v(" "),s("h2",{attrs:{id:"字符串常量池详解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池详解"}},[a._v("#")]),a._v(" 字符串常量池详解")]),a._v(" "),s("h3",{attrs:{id:"字符串常量池的设计思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池的设计思想"}},[a._v("#")]),a._v(" 字符串常量池的设计思想")]),a._v(" "),s("p",[a._v("字符串作为最基础的类型，会被大量的使用，如果频繁的创建字符串对象，会导致内存的浪费，所以Java设计了字符串常量池，用来存放字符串对象。")]),a._v(" "),s("blockquote",[s("p",[a._v("字符串常量池是在堆内存中的，不是在方法区中的。 创建字符串对象的时候，会先去字符串常量池中查找是否有相同的字符串，如果有，就返回引用，如果没有，就创建一个新的字符串对象。")])]),a._v(" "),s("p",[a._v("字符串常量池位置")]),a._v(" "),s("ul",[s("li",[a._v("JDK1.6 有永久代，运行时常量在永久代中，运行时常量包括字符串常量池")]),a._v(" "),s("li",[a._v("JDK1.7 有永久代，运行时常量在永久代中，字符串常量池从永久代中移动到堆中")]),a._v(" "),s("li",[a._v("JDK1.8+ 无永久代，运行时常量在元空间中，字符串常量池在堆中")])])])}),[],!1,null,null,null);s.default=e.exports}}]);