---
title: 线程池
date: 2022-08-04 10:26:56
permalink: /pages/d936e6/
categories:
  - 基础原理知识
tags:
  - 
author: 
  name: weiluoliang
  link: https://github.com/weiluoliang
---



## 线程池原理



### 内部结构图

![](https://media-1251528481.cos.ap-hongkong.myqcloud.com/blog/线程池原理图.png)



### 状态流转 

![](https://media-1251528481.cos.ap-hongkong.myqcloud.com/blog/线程池状态流转.png)



**问： 线程池shutdown与shutdownNow的区别？** 

shutdown方法不接收新的任务，但是会继续把队列中的任务执行完再关闭。  

shutdownNow是不接收新任务，也不执行队列中的任务，中断所有线程。



使用线程池注意：

1. 指定容量
2. 不使用FixedThreadPool() 没有指定容量，可能发生OOM



## 源码解析

### 参数说明

```java
/** 用一个字段记录线程数和状态,高3位为状态，低29位记录线程数 */
private final AtomicInteger ctl = new AtomicInteger(ctlOf(running,0));
private final int count_bits = Integer.SIZE - 3;
/** 容量 ： 000 11111 11111111 11111111 11111111  */
private final int capacity = ( 1 << count_bits ) - 1 ;

// 运行中
private final static int running    = -1 << 29; // 111 00000000000000000000000000000
// 关闭, 拒绝新任务，队列中的任务还是可以执行
private final static int shutdown   = 0 << 29;  // 000 00000000000000000000000000000
// 关闭 拒绝新任务，队列的任务也不处理了
private final static int stop       = 1 << 29;  // 001 00000000000000000000000000000
// 整理 ， shutdown -> tidying , stop->tidying 
private final static int tidying    = 2 << 29;  // 010 00000000000000000000000000000
// 终止 ，线程池停止了
private final static int terminated = 3 << 29;  // 011 00000000000000000000000000000
```

 

### 提交任务

```java
public void execute(Runnable command) {
    // 1. 是否达到了核心线程数？ 没有先创建线程
    int c = ctl.get();
    if(workerCountOf(c) < coreSize){
        // 添加一个核心线程，并提交任务，如果成功了直接就返回了。
        if(addWorker(command,true)){
            return;
        }
        // 并发场景 状态可能已经被其他线程修改，需求重新获取，进入下一个阶段的判断
        c = ctl.get();
    }
    // 2. 加入队列
    if(isRunning(c) && queue.offer(command)){
        int recheck = ctl.get();
        // 再次检查线程池的状态,如果已经关闭了，直接就拒绝
        if(!isRunning(c) && remove(command)){
            reject(command);
        } // 如果运行状态是正常的，就检查当前是否线程？ 没有就新增一个线程去处理任务 .
        else if(workerCountOf(recheck) == 0){
            addWorker(null,false);
        }
    }
    // 3. 队列满了， 如果还没有达到最大线程数，就继续创建非核心的线程
    else if(!addWorker(command,false)){
        // 4. 执行拒绝策略
        reject(command);
    }
}


private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;){
            int c = ctl.get();
            int rs = runStatusOf(c);
            // 如果线程池已经关闭了，队列不为空才可以加线程（work），并且不能添加任务
            if(rs >= shutdown && !(rs == shutdown && firstTask == null && !queue.isEmpty())){
                return false;
            }
            // 添加线程数
            for (;;){
                // 当前线程的数量
                int wc = workerCountOf(c);
                // 判断是否到达了容量限制
                // 1. 是否到达了最大容量？
                // 2. 是否到达了核心线程数？
                // 3. 是否到达了最大的线程数量？
                if(wc >= capacity || wc >= (core ? coreSize:maxSize) ){
                    return false;
                }
                // 添加线程
                if(compareAndIncrementWorkCount(c)){
                    break retry;
                }
                // 如果线程池状态发生了变化?
                c = ctl.get();
                if(runStatusOf(c) != rs ){
                    continue retry;
                }
            }
        }
        // 1. 把线程加入集合 workers
        // 2. 启动线程
        // 3. 如果失败了做收尾工作
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = new Worker(firstTask);
        try {
            Thread t = w.thread;
            if (t != null) {
                mainLock.lock();
                try {
                    // 再次校验线程池的状态
                    int rs = runStatusOf(ctl.get());
                    if(rs < shutdown || (rs == shutdown && firstTask == null)){
                        if(t.isAlive()){
                            throw new IllegalThreadStateException("线程状态不正确");
                        }
                        workers.add(w);
                        workerAdded = true;
                    }
                }finally {
                    mainLock.unlock();
                }
                if(workerAdded){
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if(!workerStarted){
                addWorkerFailed(w);
            }
        }
        return workerStarted;
    }
```



### 线程池执行任务

```java
private void runWorker(Worker w) {
    Thread thread = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // 允许中断
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null){
            w.lock();
            // 如果状态已经是 STOP 了 就要去中断线程了
            if(runStatusAtLess(ctl.get(),stop) && !thread.isInterrupted()){
                thread.interrupt();
            }
            try {
                beforeExecute(thread,task);
                task.run();
                afterExecute(thread,task);
            } finally {
                task = null ;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w,completedAbruptly);
    }
}

private Runnable getTask() {
    // 超时判断 是否超时
    // 线程池状态判断 是否关闭
    boolean timeOut = false;
    for (;;){
        int c = ctl.get();
        int rs = runStatusOf(c);
        if(rs >= shutdown && (stop == rs || queue.isEmpty()) ){
            return null;
        }
        int wc = workerCountOf(c);
        boolean timed = wc > coreSize || allowCoreThreadTimeOut ;
        if((wc > maxSize || (timed && timeOut)) && (wc > 1 || queue.isEmpty())){
            if(compareAndDecrementWorkCount(c)){
                return null;
            }
            continue;
        }
        // 获取任务 ， 处理超时
        try {
            Runnable task = timed ? 
                queue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : queue.take() ;
            if(task != null){
                return task;
            }
            timeOut = true;
        } catch (InterruptedException e) {
            timeOut = false;
        }
    }
}

private void processWorkerExit(Worker w, boolean completedAbruptly) {
        // 如果线程被中断了
        if(completedAbruptly){
            decrementWorkCount();
        }
        // 调整 workers
        ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            workers.remove(w);
        }finally {
            mainLock.unlock();
        }
        //尝试终止线程池
        tryTerminate();
        // 如果调用了 tryTerminate，线程池还是没有到STOP状态
        // 继续添加一个非核心线程到线程池中
        int c = ctl.get();
        if(runStatusLessThan(c,stop)){
            int min = allowCoreThreadTimeOut ? 0 : coreSize ;
            // 如果队列还有任务，确保要有线程去处理
            if( min == 0 || !queue.isEmpty() ){
                min  = 1 ;
            }
            if(workerCountOf(c) >= min){
                return ;
            }
            addWorker(null,false);
        }
    }
```



### 关闭线程池 

#### shutdown: 不接收新任务，执行完队列的任务后关闭 ❎

```java
public void shutdown(){
    // 0. 检查修改线程的权限，确保有中断线程的权限
    // 1. 修改为shutdown状态
    ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        advanceRunStatus(shutdown);
        // 2. 去中断空闲的线程,getTask中等待获取任务的线程。
        interruptIdleWorkers(false);
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    // 3. 执行tryTerminate
    tryTerminate();
}
```

#### shutdowNow: 不接受新任务，也不执行队列的任务

```java
public List<Runnable> shutdownNow(){
    ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    List<Runnable> tasks ;
    try {
        // 1. 改状态为停止
        advanceRunStatus(stop);
        // 2. 中断所有线程
        interruptWorkers();
        // 3. 获取没有执行的线程
        tasks = trainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
```



#### tryTerminate : 终止线程池

```java
private void tryTerminate() {
        for (;;){
            int c = ctl.get();
            //检查如果线程还是Running ，就直接return
            if(isRunning(c)
                    || runStatusAtLess(c,tidying)  // 如果已经到了整理阶段，说明也不需要再继续运行了
                    || (runStatusOf(c) == shutdown && !queue.isEmpty())){ // 线程池处于关闭状态，但是队列中还有任务还是不能关闭的。
                return;
            }
            // 还有线程，不能直接终止，发起一个中断操作 。
            if(workerCountOf(c) != 0 ){
                interruptIdleWorkers(ONLY_ONE);
                return;
            }
            ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                if(ctl.compareAndSet(c,ctlOf(tidying,0))){
                    try {
                        terminated();
                    } finally {
                        ctl.compareAndSet(c,ctlOf(terminated,0));
                    }
                }
            }finally {
                mainLock.unlock();;
            }
        }
    }
```



## 扩展点

beforeExecute()  

afterExecute()

terminated()



### 如何预估线程池的大小 ？ 

1.  IO密集型还是CPU密集型？
   1. cpu密集型 ：减少上下文切换    N+1  
   2. IO密集型 ：  核心线程数 = 2N + 1  

动态调整 ：  
