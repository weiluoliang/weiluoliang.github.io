---
title: 线程在JVM的底层实现
date: 2022-08-15 19:30:50
permalink: /pages/d6313d/
categories:
  - 基础原理知识
tags:
  - 
author: 
  name: weiluoliang
  link: https://github.com/weiluoliang
---
# 线程在JVM的底层实现



JVM源码类 ： 

​      Thread.c ,  jvm.cpp  ， os_linux.cpp

注意： **线程不能启动多次 ，抛出异常** 



入口 ：  jvm.cpp  `JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))`

```c
native_thread = new JavaThread(&thread_entry, sz); //创建一个对应的内核线程，这里注意thread_entry，后续会执行这个方法

```

 

先做Java_Thread 与OS_thread的映射,然后通过  pthread_create() 创建操作系统线程  。

创建好线程之后，线程会一直处于阻塞等待状态，直到被唤醒

```c
osthread->set_state(INITIALIZED);
sync->notify_all();
while(osthread->get_state() == INITIALIZED ){
    sync->wait(Mutex::_no_safepoint_check_flag);
}
thread->run(); //回调run方法
```







【thread.cpp:451】启动线程，主要是设置状态为RUNNABLE(java_start方法中会感知，然后initialized状态修改为RUNNABLE,流程继续往下调用run方法)

```c
void Thread::start(Thread* thread) { //jvm.cpp中的方法调过来的
  trace("start", thread);
  // Start is different from resume in that its safety is guaranteed by context or
  // being called from a Java method synchronized on the Thread object.
  if (!DisableStartThread) { //DisableStartThread默认是false
    if (thread->is_Java_thread()) { //如果是java线程，设置线程状态 RUNNABLE
      // Initialize the thread state to RUNNABLE before starting this thread.
      // Can not set it after the thread started because we do not know the
      // exact thread state at that time. It could be in MONITOR_WAIT or
      // in SLEEPING or some other state.
      java_lang_Thread::set_thread_status(((JavaThread*)thread)->threadObj(),
                                          java_lang_Thread::RUNNABLE);
    }
    os::start_thread(thread);  //启动原生线程,这里是启动线程真正入口，目的是改变线程状态
  }
}

```





[os.cpp:859] 改变操作系统的线程状态为【RUNNABLE】

```c
void os::start_thread(Thread* thread) {
  // guard suspend/resume
  MutexLockerEx ml(thread->SR_lock(), Mutex::_no_safepoint_check_flag);
  OSThread* osthread = thread->osthread();
  osthread->set_state(RUNNABLE);    //这里设置线程状态为RUNNABLE状态，很重要，设置完之后在java_start方法中感知
  pd_start_thread(thread);//java_start方法中判断状态为RUNNABLE了，于是放行，执行run。
}
```





thread_main_inner 执行具体的run方法并在执行完成销毁当前实例

```c
void JavaThread::thread_main_inner() {
  assert(JavaThread::current() == this, "sanity check");
  assert(this->threadObj() != NULL, "just checking");

  // Execute thread entry point unless this thread has a pending exception
  // or has been stopped before starting.
  // Note: Due to JVM_StopThread we can have pending exceptions already!
  if (!this->has_pending_exception() &&
      !java_lang_Thread::is_stillborn(this->threadObj())) { //如果没有待处理异常且没有被中止
    {
      ResourceMark rm(this);
      this->set_native_thread_name(this->get_thread_name());
    }
    HandleMark hm(this);
    this->entry_point()(this, this);  //回调线程run入口。执行entry_point函数，就是执行Thread的run方法
  }

  DTRACE_THREAD_PROBE(stop, this);

  this->exit(false); //run方法执行完成，准备退出线程
  delete this; //释放JavaThread对应的内存
}
```

