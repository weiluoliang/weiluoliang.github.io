---
title: MESI
date: 2022-05-11 09:06:29
permalink: /pages/cb4439/
categories:
  - 操作系统
tags:
  - 
author: 
  name: weiluoliang
  link: https://github.com/weiluoliangxi
---





##  CPU体系结构的种类

[SMP、NUMA、MPP体系结构介绍](https://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html)



## 为什么需要内存屏障？

CPU执行指令时，会进行重排序，因此可以获取更好的性能，但是如果指令具有依赖性，需要按照顺序执行时，我们就需要使用内存屏障，强制顺序执行。



## 缓存一致性协议状态（MESI States）

M :  Modified (修改)

E :  Exclusive（独占）

S :   shared (共享)

I ： Invalid（失效）

## 缓存一致性协议消息（MESI Protocol Messages）

**Read** : 读一条消息 

**Read Response:** 回复读消息， 由内存或者其他cache发起

**Invalidate**： 失效消息 ，使其他cache的缓存失效

**Invalidate Acknowledge**： 一个CPU收到Invalidate消息之后，回复invalidate消息。

**Read Invalidate**： 读一个内存地址，并使其他缓存失效。

**Writeback**： 回写到内存

如果缓存中的数据已经被修改，并且缓存已经满了，此时要读取其他数据进到缓存，就必须弹出这条数据，回写到内存，以便由空间保存新的数据到缓存中。



问题： 如果两个CPU同时想失效相同的缓存行，会发生什么？ 

回答： 先访问CPU的获胜，另外一个CPU使其高速缓存中的副本失效，并返回invalidate ack消息给获胜的CPU



## **Store Buffer**

假如要修改一个变量a， 发生一条 `invalidate(a)`消息 ，需要等待ack才能进行下一步的修改操作, 效率低下，为了解决这个问题引入了store buffer。

![storebuffer ack](https://media-1251528481.cos.ap-hongkong.myqcloud.com/blog/store-buffer-ack.png)

引入`store buffer`后，修改一个变量的操作

1. 如果当前`变量a`是shared状态 发出一条 `invalidate(a)`消息，使其他cup缓存中的`变量a` 失效
2. 修改`变量a`的值放入store buffer中
3. 可以继续指令其他指令...
4. 等到接收到 `invalidate ack`消息 ,就可以同步修改到`cache`中



![](https://media-1251528481.cos.ap-hongkong.myqcloud.com/blog/store-buffer-3.png)



**store buffer 带来的问题： 可见性**

store buffer中的数据只对当前的CPU可见，修改变量保存到store buffer中之后，需要等到ack消息到达或者store buffer达到了刷新阈值（store buffer容量有限，准备满了就要刷新）才进行刷新到缓存，如果还没更新到缓存中，其他CPU这个时候来读数据，其实还使读到cache line中的旧数据，没有办法获取store buffer中最新的数据，这就是可见性问题。 要解决这个问题，引入的内存屏障。

### 内存屏障（ **Memory Barriers**）

加入内存屏障，在执行写操作之前，会刷新store buffer到缓存中。

CPU实现内存屏障的操作，可以有两种：

1. 短暂的等待，store buffer刷新到cache中再做写操作
2. 到store buffer中排队，等前面的写操作更新之后再进行更新。

## invalidate queue

store buffer的容量非常小，CPU的写操作可以很快的填满它，如果接收不到 invalidate ack消息，此时就必须等待，无法进行写操作。这个地方又导致了CPU等待，效率低下。

**这种情况可以进一步改进提升性能，就是通过让 invalidate ack消息快速返回。----- invalidate queue** 。 

### ACK消息慢的原因

cache接收到 invalidate消息之后，使其缓存失效之后再发送ack，导致发送ack的消息等待比较久，其实失效的操作可以延迟，可以先快速返回ack消息。

另外，如果短时间内大量的invalidate message到达，cpu会比较繁忙处理不过来，这种情况可能会导致其他CPU阻塞等待。

### **Invalidate Queues**

![](https://media-1251528481.cos.ap-hongkong.myqcloud.com/blog/20220811155556.png)

cpu接收到 invalidate消息，保存到 invalidate queue后马上回复ack ，延迟处理失效。这里又再次导致了可见性的问题，因为如果此时再次读取要被失效的数据，但是还没有执行失效操作，就会读到旧的数据。

**内存屏障**， 我们需要在读取之前，处理invalidate queue。 手动添加内存屏障，告诉CPU强制刷新。 这样又可以保障了 MESI的一致性。



**内存屏障的类型**：

1. 写屏障(write memory barrier)  ：  处理 store buffer
2. 读屏障(read memory barrier)  ：  处理 invalidate queue 
3. 全屏障(full-flfledged memory barrier)  ：  处理 store buffer和 invalidate queue . 



## 附录

【Paul E. McKenney】[Is Parallel Programming Hard, And, If So,What Can You Do About It?](https://cdn.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html)

