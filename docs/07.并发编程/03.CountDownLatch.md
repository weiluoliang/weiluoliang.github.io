---
title: CountDownLatch的原理
date: 2022-05-05 13:53:19
permalink: /pages/5e029b/
categories:
  - 并发编程
tags:
  - 
author: 
  name: weiluoliang
  link: https://github.com/weiluoliang
---



## 前言 

这个是一个JUC包下提供给多线程协同工作的工具，可以让线程等待满足某些条件之后进行后续的业务处理。如：爬虫程序，我们开启多个线程去网络上请求一些数据，主线程等待所有请求线程处理完毕后，进行数据的处理工作。

内容涉及以下： 

1. 如何判断等待条件满足？
2. 底层数据结构剖析
3. 线程的唤醒机制



## 如何判断等待条件满足？

CountDownLatch中使用了state做计数器，初始化的时候给定一个值，当这个值减少到0，就满足了等待的条件，程序可以继续往下执行。`countDown()`方式是对state的减操作，state只能减少，不能增加。以下是使用示例：

```java
public class CountDownLatchTests {

    public static void main(String[] args) throws InterruptedException {

        // 初始化 state = 5 ，需要countDown()5次
        CountDownLatch countDownLatch = new CountDownLatch(5);

        for (int i = 0; i < 5 ; i++) {
            new Thread(()->{
                // 模拟业务逻辑
                long start = System.currentTimeMillis();
                try {
                    Thread.sleep(new Random().nextInt(1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                long end = System.currentTimeMillis();
                String name = Thread.currentThread().getName();
                System.out.println(name + "处理完毕. 耗时 ： " + (end - start) );
                countDownLatch.countDown();
            },"t"+i).start();
        }
        // 阻塞等待
        countDownLatch.await();
        System.out.println("主线程处理完毕 . ");
    }
}

//t0处理完毕. 耗时 ： 211
//t3处理完毕. 耗时 ： 214
//t1处理完毕. 耗时 ： 425
//t2处理完毕. 耗时 ： 485
//t4处理完毕. 耗时 ： 743
//主线程处理完毕 . 
```

## 底层数据结构剖析

通过以上的例子，我们可以看到需要一个计数器`state`记录需要`countDown()`的次数。有线程等待，所以这里还需要一个队列。我们可以得到一个抽象的模型。

```java
public class CountDownLatch{
	 // 计数器
    private volatile int state; 
	
    /* 
            +------+  prev +-----+       +-----+
       head |      | <---- |     | <---- |     |  tail
            +------+       +-----+       +-----+
     */
    // 队列的头部
    private Node head;
    // 队列的尾部
    private Node tail;
    
    // 节点
    public static class Node{
        private Thread thread;
        private Node prev;
        private Node next;
    }
}
```

JDK源码中的实现并没有直接在`CountDownLatch`中实现，而是通过一个属性`Sync`去继承`AbstractQueuedSynchronizer`，因为在并发场景下，有很多共性，独占锁，读写锁，阻塞队列和线程池都有使用到`state`和`队列`的操作，Doug Lea大师把这些共性的逻辑都写在了`AbstractQueuedSynchronizer`。
