---
title: 线程池
date: 2022-05-09 14:33:04
permalink: /pages/c59723/
categories:
  - 并发编程
tags:
  - 
author: 
  name: weiluoliang
  link: https://github.com/weiluoliang
---
# 线程池

## 为什么要有线程池

线程的创建和销毁相当的消耗资源，而程序执行的时间其实很短，若每次执行任务都去创建线程，大部分的资源都去创建线程和销毁线程。 如果创建好线程，并不销毁，下次执行任务的时候直接使用已经创建好的线程，就节省了创建线程所耗费的资源。

### 线程池的优点：

- 节省资源： 避免频繁创建线程耗费资源
- 提高响应速度 ： 直接使用创建好的线程去执行任务会更快。
- 便于管理线程： 线程资源是有限的，不能一直创建，如果并发量很高，不断的去创建资源，会导致资源耗尽。 

## 重要参数解析

```java
    // 包含 状态（高3位）和线程数（低29位，约5亿个线程）
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    // 线程所占用的二进制位数（29位）
    private static final int COUNT_BITS = Integer.SIZE - 3;
    //容量 2^29 - 1  
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS;

```



**Doug Lea** 使用一个字段`ctl`表示了线程池的状态和线程数量， 高3位表示线程池的状态，低29位表示线程数量。占用非常少的资源。获取线程状态和线程数量都是通过位运算获取。

### 获取线程状态 

 我们首先看一下各状态在二进制的表示，只看高3位

```
RUNNING    ：1110 0000 0000 0000 0000 0000 0000 0000   （-1）
SHUTDOWN   ：0000 0000 0000 0000 0000 0000 0000 0000   （0）
STOP       ：0010 0000 0000 0000 0000 0000 0000 0000   （1）
TIDYING    ：0100 0000 0000 0000 0000 0000 0000 0000   （2）
TERMINATED ：0110 0000 0000 0000 0000 0000 0000 0000   （3）
```

获取状态的方法

```java
private static int runStateOf(int c)     { return c & ~CAPACITY; }
```

`CAPACITY`的结果为 `0001 1111 1111 1111 1111 1111 1111 1111` 

取反之后为 `1110 0000 0000 0000 0000 0000 0000 0000 ` ,   c &  ~CAPACITY 只会保留 c 的高3位，就是线程的状态了。 

### 获取线程数量

线程数量是通过低29位表示的，CAPACITY正好是29个1 ， ctl &  CAPACITY 即可获取到 线程池的线程数量。



## 任务提交的处理逻辑

1. `workerCountOf(c) < corePoolSize`   ， 线程池数量小于核心线程数，创建线程处理
2. 线程数 >= corePoolSize 且队列未满 ， 任务保存到队列中
3. 线程数 >= corePoolSize 且 队列已满 ，此时线程数 maximumPoolSize ，会创建线程取处理任务。
4. 当线程数大于 maximumPoolSize ， 执行拒绝策略。



### addWorker

```java
private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 如果是关闭了，不接收新的任务 
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

###  runWorker

```java
final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```



### getTask

```java
 private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```



## 线程池的最佳实战

### 使用有界队列

《阿里巴巴Java开发手册》中不允许使用 `Executors.newFixedThreadPool()`创建线程池，因为使用了无界队列 `LinkedBlockingQueue` ，如果堆积的任务很多，可能会导致OOM ，所以不推荐使用。`Executors.newCachedThreadPool()` 的最大线程数是 `Integer.MAX_VALUE`,可以认为是没有上限的，每创建一个线程，默认是`1MB`的内存，内存耗尽也会导致OOM



### 线程数的计算

   - CUP密集型 ：  这种类型非常消耗CPU，设置成N（核心数）+1 ，+1是为了防止缺页中断导致CPU空闲
   - IO密集型：这种类型大部分时间都是在处理IO，而IO并不消耗CPU，可以设置为：  2N   



## 参考资料

[dunwu-Java线程池](https://dunwu.github.io/javacore/pages/241a67)

[编程之美！从线程池状态管理来看二进制操作之美](https://www.jianshu.com/p/bd13cc59667b)

[线程池源码解析4.runWorker()](https://www.csdn.net/tags/MtTaEg5sNjI4NTExLWJsb2cO0O0O.html)



