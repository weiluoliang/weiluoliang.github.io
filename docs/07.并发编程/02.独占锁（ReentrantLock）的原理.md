---
title: 独占锁（ReentrantLock）的原理
date: 2022-05-05 11:29:45
permalink: /pages/f91ea1/
categories:
  - 并发编程
tags:
  - 
author: 
  name: weiluoliang
  link: https://github.com/weiluoliang
---


## 独占锁的特性
  - 只有一个线程能获取锁
  - 其他线程等待
  - 获取锁的线程可以重入


## 独占锁的基本构成

1. state
2. exclusiveThread
3. 队列
   1. Node节点
   2. head指针
   3. tail指针
 
独占锁的核心思想： 使用state表示锁资源，锁初始化阶段`state=0`表示当前没有线程持有锁，当有线程获取锁之后`state=1`，
exclusiveThread保存获取锁的线程。其他没有获取锁的线程会进入队列排队并通过`LockSupport.park()`阻塞等待唤醒。

## 获取锁的逻辑

### 公平锁

1. acquire(1) → 
    1. tryAcquire(arg);  **_公平性的体现_**
    2. addWaiter(node);   加入队列
    3. acquireQueue(node) 在队列中自旋等待唤醒



### 非公平锁

1.compareAndSetState(0,1) **_非公平性的体现_**  

2. acquire(1) →    
     2.1. tryAcquire(arg);  **_非公平性的体现_**  
     2.2. addWaiter(node);   加入队列  
     2.3. acquireQueue(node) 在队列中自旋等待唤醒  


### 取消锁的逻辑
 1. 当自旋抢锁发生异常时，去执行取消当前排队  


## 思考题： 

1. 重入锁是如何实现的？ 
2. `lock()` 和 `lockInterruptibly()` 的区别。
3. 公平锁与非公平锁的区别在哪里？ 
4. 一个线程进入队列之后，会做哪些操作？ 
5. 在队列中等待的线程什么时候会被唤醒？ 
